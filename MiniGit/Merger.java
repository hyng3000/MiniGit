package MiniGit;

import java.io.File;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import static MiniGit.FileUtilities.newFiles;
import static MiniGit.FileUtilities.readContentsAsString;

/**
 * The Merger class merges the tracked files of two branches according to the content of the split point
 * and the merge rules
 * The merge takes place on initialization with results available by the getMergedFiles() method,
 * and the getMessage() method.
 * */
public class Merger {

    Map<String, String> splitPoint;
    Map<String, String> head;
    Map<String, String> other;
    File storedFiles;
    Map<String, String> mergedFiles;
    String message;

    Merger(Commit splitPoint, Commit head, Commit other, File storedFileLocation){
        this.splitPoint = splitPoint.getTrackedFiles();
        this.head = head.getTrackedFiles();
        this.other = other.getTrackedFiles();
        storedFiles = storedFileLocation;

        message = "Merged " + other.getBranch() + " into " + head.getBranch() + "\n";
        mergedFiles = merge();

    }

    /**
     * Returns the merged Files in Map<String,String> format.
     * */
    public Map<String,String> getMergedFiles(){
        return mergedFiles;
    }

    /**
     * Returns the message string generated by the merge.
     * */
    public String getMessage(){
        return message;
    }


    /**
     * Carries out a merge of two branches.
     * Returns a Map<String,String> of name -> Sha1 Strings
     * that represent the files the merged Commit should track.
     * */
    private Map<String, String> merge(){

        HashMap<String, String> newTrackedFiles = new HashMap<>();
        Set<String> all = new HashSet<>(head.keySet());
        all.addAll(other.keySet());

        for (String name: all){
            try {

                String version = selectVersionToKeep(name);
                newTrackedFiles.put(name, version);

            } catch (IllegalArgumentException e){
                System.out.println("Unable to Merge");
                System.out.println(e.getMessage());
                return null;
            }
        }

        return newTrackedFiles;
    }

    /**
     * Selects which version of a file should be kept according to the merge rules.
     * */
    private String selectVersionToKeep(String name){

        String result;

        if (!nameContainedByAtLeastOne(name)){
            throw new IllegalArgumentException("File name must be present in at least one branch");
        }

        String headVersion = head.get(name);
        String otherVersion = other.get(name);
        String splitVersion = splitPoint.get(name);


        if (nameContainedByAll(name) && splitVersion.equals(headVersion) && splitVersion.equals(otherVersion)){
            return splitVersion;
        }
        // If a file name is found in all three
        // And splitPoint has the same version as head
        // but others version is different
        // -> That means it has been modified in other
        if (nameContainedByAll(name) && splitVersion.equals(otherVersion) && !splitVersion.equals(headVersion)){
            //    keep other version
            result = otherVersion;
            return result;
        }


        // If a file name is found in all three
        // And splitPoint has the same version has other
        // but head versions copy is different
        // -> That means it has been modified in head
        if (nameContainedByAll(name) && splitVersion.equals(otherVersion) && !splitVersion.equals(headVersion)){
        //          keep head version
            result = headVersion;
            return result;
        }

        // if a file name is found in all three
        // but is different in all three
        // it has been modified in both head and other
        // this is a merge conflict
        if (
                nameContainedByAll(name) &&
                        !splitVersion.equals(headVersion) &&
                        !splitVersion.equals(otherVersion) &&
                        !headVersion.equals(otherVersion)
        ) {
            System.out.println("Merge Conflict Found -> " + name);
            return conflictResolver(name, headVersion, otherVersion);
        }

        // if splitPoint and OTHER do not contain a file of this name,
        // but head does
        // -> it has been created in head
        if (!splitPoint.containsKey(name) && !other.containsKey(name) && head.containsKey(name)){
            // keep file from head
            result = headVersion;
            return result;
        }

        // if splitPoint and HEAD do not contain a file of this name,
        // but other does
        // -> it has been created in other
        if (!splitPoint.containsKey(name) && !head.containsKey(name) && other.containsKey(name)) {
            // keep file from other
            result = otherVersion;
            return result;
        }

        // if split and other have same version,
        // and no file of that name exists in head
        // -> it has been deleted in head
        if (splitVersion != null && splitVersion.equals(otherVersion) && !head.containsKey(name)){
            return null;
        }

        // if split and head have same version,
        // and no file of that name exists in other
        // -> it has been deleted in other
        if (splitVersion != null && splitVersion.equals(headVersion) && !other.containsKey(name)){
            // do not keep file
            return null;
        }

        throw new IllegalArgumentException("A valid argument must be examinable for merge.");
    }

    /**
     * Checks head, other, and splitPoint and returns true if all three contain said 'name' as a key.
     * */
    private Boolean nameContainedByAll(String name){
        return (head.containsKey(name) && other.containsKey(name) && splitPoint.containsKey(name));
    }

    /**
     * Checks head, other, and splitPoint and returns true if at least one of the three contain said 'name' as a key.
     * */
    private Boolean nameContainedByAtLeastOne(String name){
        return (head.containsKey(name) || other.containsKey(name) || splitPoint.containsKey(name));
    }

    /**
     * Handles Merge conflicts that arise during a merge.
     * Two files that are in conflict are concatenated to one file in a format to help the user differentiate
     * the separate files and resolve the conflict manually.
     * Returns a string of the content of the concatenated files.
     * */
    private String conflictResolver(String name, String headVersion, String otherVersion){

            File headVersionFile = newFiles(storedFiles, name, headVersion);
            File otherVersionFile = newFiles(storedFiles, name, otherVersion);

            try {

                String headVersionContent = readContentsAsString(headVersionFile);
                String otherVersionContent = readContentsAsString(otherVersionFile);
                String mergedString = concatConflictStrings(headVersionContent, otherVersionContent);
                message += ("Encountered a merge conflict with file: " + name) + "\n";
                return StoredFiles.writeStringToMiniGitFormatFile(name, mergedString, storedFiles);

            } catch (IllegalArgumentException e){
                System.out.println("Unable to Resolve Conflict -> Files cannot be read as text");
                System.out.println(e.getMessage());
                return null;
            }
    }

    /**
     * Formats given strings according to the conflict File format.
     * */
    private String concatConflictStrings(String headerVersionString, String otherVersionString){

        String mergeFormatTop =
                """
                
                <<<<<<<<<
                Content of conflicting file in Head
                
                """;
        String mergeFormatMiddle =
                """

                ==========           ==========
                Content of conflicting file in other Specified Branch
                
                """;
        String mergeFormatBottom = "\n\n>>>>>>>>>>";

        return mergeFormatTop +
                headerVersionString +
                mergeFormatMiddle +
                otherVersionString +
                mergeFormatBottom;
    }


}
